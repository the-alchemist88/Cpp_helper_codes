LAMBDA EXPRESSION FEATURES

- Function call operator of compiler generated type has auto return type, which means return type will be deduced from return expression.

- The variables inside the lambda capture can be thought as non-static data members of compiler generated type:

class Compiler_Generated
{
public:
    auto operator()(int x) const
    {
        return capture * x;
    }
private:
int capture;
};

- Function call operator of compiler generated type for lambda expression is a const member function,which means it cannot change the copy captured
object. However if the object is captured by reference then it can change because lambda expression actually changes the referenced object, not the
data member:

int x{ 10 };
class Ref
{
public:
	Ref(int& val): r(val){} // now r refers to argument that is sent
	auto operator()() const { return ++r; } // reference doesn't change, can be thought as constant pointer
private:
	int& r;
};

auto demo = Ref(a)();

cout << "demo = " << demo << '\n'; // demo and x is 11
cout << "x = " << x << '\n';

- If mutate keyword is placed in lambda expression, then it rules out the const qualifier in function call operator:

[x]()mutate{ ++x ;}

- Function call operator returns a constant expression if it doesn't violate the rules of constexpr requirements, otherwise returns a not constant
expression(for example static variables cannot be used to initialize constexpr variables):

constexpr int ci = []{static int x = 10; return x * x;}(); // error

- In order to check whether a lamba expression returns a constant expression, use constexpr keyword inside lambda after paranthesis:

constexpr int ci = []()constexpr{int x = 10; return x * x;}();

- If any of the qualifiers below is used in lambda expression then paranthesis must be placed even if inside is empty:
[]()mutable{code}
[]()noexcept{code}
[]()constexpr{code}
[]()->int{code}
