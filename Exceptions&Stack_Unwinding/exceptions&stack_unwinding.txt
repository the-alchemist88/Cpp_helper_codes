Exceptions and Stack Unwinding in C++
-------------------------------------

In the C++ exception mechanism, control moves from the throw statement to the first catch statement that can handle the thrown type. When the catch statement is reached, all of the
automatic variables that are in scope between the throw and catch statements are destroyed in a process that is known as stack unwinding. In stack unwinding, execution proceeds as
follows:

1) Control reaches the try statement by normal sequential execution. The guarded section in the try block is executed.

2) If no exception is thrown during execution of the guarded section, the catch clauses that follow the try block are not executed. Execution continues at the statement after the last
catch clause that follows the associated try block.

3) If an exception is thrown during execution of the guarded section or in any routine that the guarded section calls either directly or indirectly, an exception object is created 
from the object that is created by the throw operand. (This implies that a copy constructor may be involved.) At this point, the compiler looks for a catch clause in a higher 
execution  context that can handle an exception of the type that is thrown, or for a catch handler that can handle any type of exception. The catch handlers are examined in order of
their  appearance after the try block. If no appropriate handler is found, the next dynamically enclosing try block is examined. This process continues until the outermost enclosing 
try block is examined.

4) If a matching handler is still not found, or if an exception occurs during the unwinding process but before the handler gets control, the predefined run-time function terminate is 
called. If an exception occurs after the exception is thrown but before the unwind begins, terminate is called.

5) If a matching catch handler is found, and it catches by value, its formal parameter is initialized by copying the exception object. If it catches by reference, the parameter is
initialized to refer to the exception object. After the formal parameter is initialized, the process of unwinding the stack begins. This involves the destruction of all automatic 
objects that were fully constructed—but not yet destructed—between the beginning of the try block that is associated with the catch handler and the throw site of the exception. 
Destruction occurs in reverse order of construction. The catch handler is executed and the program resumes execution after the last handler—that is, at the first statement or 
construct that is not a catch handler. Control can only enter a catch handler through a thrown exception, never through a goto statement or a case label in a switch statement.


Notes:
-------
- std::terminate calls std::abort

- Stack unwinding doesn't applied if the exception cannnot get caught.

- The parameter of catch block(exception objecy) is initialized by throw statement. Thus, copy elision might kick in during this process. However this parameter is typically 
<const exception&> since copy ctor of exception class can also throw exception that leads to calling std::terminate.

Resoruce utilised: https://learn.microsoft.com/en-us/cpp/cpp/exceptions-and-stack-unwinding-in-cpp?view=msvc-170
Article Date: 11/14/2022
