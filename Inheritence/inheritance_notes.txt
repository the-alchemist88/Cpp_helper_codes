INHERITANCE - General Features
--------------------------------------

Inside a derived class object, there is actually a base class object. This can be seen in the assembly code generated by the compiler and examined by using the sizeof operand.
sizeof(Base) <---> sizeof(Derived)

The base class to be inherited from, must be a complete type.

In a derived class, writing a "using declaration" for member functions or data members of the base class can have two purposes:

1) Adding the members(those not in private but possible protected) of the base class into the public interface of the derived class so that client codes
of derived class can use them.

2) Forming a function overloading mechanism between base class functions and derived class functions. If the derived class has a function with the same
name and parametres, then derived class functions will have the priority.


class Base
{

protected:
	void foo(int x)
	{
		cout << "Base::foo(int x)\n";
	}

	void bar(int x)
	{
		cout << "Base::bar(int x)\n";
	}

	void baz(int x)
	{
		cout << "Base::baz(int x)\n";
	}
};

class Derived
{
public:
	void bar(double x)
	{
		cout << "Der::bar(double x)\n";
	}

	void baz(int x)
	{
		cout << "Derived::baz(int x)\n";
	}

	using Base::foo;
	using Base::bar;

};

// test code
int main()
{
	Der dx;

	dx.foo(5);	// added base class function to derived class public interface
	dx.bar(5);	// function overloading, base class object bar function called 
	dx.bar(5.);	// function overloading, derived class object bar function called 
	dx.baz(5);	// both derived and base have the same function, it's not ambiguity. Derived class function has priority.
}

Special member functions work similarly to composition. For all implicitly declared - defaulted special functions written by the compiler in the derived
class functions, their base class counterparts are called (ex: derived class default ctor --> Base class default ctor). However, in the derived class
if a member function is written by the programmer, calling its base class counterparts(ctors, assignment operators or dtor) in the derived class member
function will be programmer's responsibility. Example:

class Base
{
public:

	Base() { cout << "Base()\n"; }

	Base(int, int) { cout << "Base(int, int)\n"; }

	Base(const Base& rhs)
	{
		cout << "Base(const Base& rhs)\n";
	}

	Base(Base&& rhs) noexcept
	{
		cout << "Base(Base&& rhs)\n";
	}

	Base& operator=(const Base& rhs)
	{
		cout << "Base& operator=(const Base& rhs)\n";
		return *this;
	}

	Base& operator=(Base&& rhs) noexcept
	{
		cout << "Base& operator=(Base&& rhs)\n";
		return *this;
	}

	void foo(int x)
	{
		cout << "Base::foo(int x)\n";
	}
};

class Der : public Base
{
public:

	Der() { cout << "Der()\n"; }

	Der(int x, int y) : Base(x, y)
	{
		cout << "Der(int, int)\n";
	}

	Der(const Der& rhs) : Base (rhs)
	{

		cout << "Der(const Der& rhs)\n";
	}

	Der(Der&& rhs) noexcept : Base (std::move(rhs))
	{
		cout << "Der(Der&& rhs)\n";
	}


	Der& operator=(const Der& rhs) 
	{
		Base::operator=(rhs);
		cout << "Der& operator=(const Der& rhs)\n";
		return *this;

	}

	Der& operator=(Der&& rhs) noexcept
	{
		Base::operator=(std::move(rhs));
		cout << "Der& operator=(Der&& rhs)\n";
		return *this;
	}

};

// test code
int main()
{

	Der da;					// default ctor

	cout << "\n";

	Der db(3, 5);			// (int, int) ctor

	cout << "\n";

	Der dc = db;			// copy ctor

	cout << "\n";

	Der dd = std::move(da);	// move ctor

	cout << "\n";

	da = dd;				// copy assignment operator

	cout << "\n";

	db = std::move(dc);		// move assignment operator

	cout << "\n";

	db.Base::foo(5);		// calling Base class function through a derived object
	db.foo(5);				// since it's a public inheritance, derived class object also has base class public functions
}

Output:
-------
Base()
Der()

Base(int, int)
Der(int, int)

Base(const Base& rhs)
Der(const Der& rhs)

Base(Base&& rhs)
Der(Der&& rhs)

Base& operator=(const Base& rhs)
Der& operator=(const Der& rhs)

Base& operator=(Base&& rhs)
Der& operator=(Der&& rhs)

Base::foo(int x)
Base::foo(int x)


Since modern C++, "inherited ctor" syntax added to language. This feature saves the the programmer from the hassle of writing base class ctors for all
all of its derived class counterparts. However, this is not feasible if base class ctors are placed in protected access control section.

class Base
{
public:

	Base() { cout << "Base()\n"; }

	Base(int)
	{
		cout << "Base(int)\n";
	}

	Base(const char*)
	{ 
		cout << "Base(const char*)\n"; 
	}

	Base(int, char)
	{
		cout << "Base(const char*)\n";
	}
};

class Der : public Base
{
public:
	using Base::Base;
};

// test code
int main()
{
	Der da;
	Der db(5);
	Der dc("Hello");
	Der dd(2, 'c');
}

Output:
-------
Base()
Base(int)
Base(const char*)
Base(const char*)

INHERITANCE ÇEŞİTLERİ(Public, Private, Protected Inheritance)
-------------------------------------------------------------------

Public Inheritance
------------------
- Public inheritance bir "is-a" ilişkisi sağlar, türemiş sınıftan taban sınıfa referans/pointer sentaksiyla örtülü dönüşüm geçerli.
- Taban sınıfın public arayüzü türemiş sınıfın public arayüzüne, taban sınıfın protected arayüzü türemiş sınıfın protected arayüzüne eklenir.
- Taban sınıfın private bölümü bütün kalıtım biçimlerinde türemiş sınıfa kapalıdır.

C++'ta görülen diğer inheritance çeşitlerinde ise durum biraz farklıdır.
 
PRIVATE INHERITANCE
--------------------

- Public inheritance'ta, taban sınıfın arayüzleri aynı şekilde türemiş sınıfa eklenir:

	base public 		--> 	derived public
	base protected 		--> 	derived protected
	
Private inhertiance'ta ise:
	
	base public 		--> 	derived private
	base protected 		--> 	derived private
	
Bunun anlamı(private inheritance): Türemiş sınıf içinde taban sınıfın yine protected ve public bölümüne erişilebilir. Ancak artık client kodlar türemiş 
sınıf üzerinden taban sınıfın kodlarını kullanamazlar.

- Bir is-a relationship yok. Türemiş sınıftan taban sınıfa örtülü dönüşüm yok. Upcasting, iki istisna dışında sentaks hatası:

a)Türemiş sınıfın üye fonksiyonu içinde upcasting (örtülü olarak) geçerli
b)Türemiş sınıfın friend'lik verdiği fonksiyonlarda geçerli

class Base
{
public:
	void foo();
};

class Der : private Base
{
	void bar()
	{
		Der myder;

		Base* bptr = &myder; // geçerli
		Base& bref = myder; // geçerli
	}

	friend void func();
	
};

void func()
{
	Der myder;

	Base* bptr = &myder; // geçerli
	Base& bref = myder; // geçerli
}

int main()
{
	Der myder;

	Base* bptr = &myder; // geçersiz
	Base& bref = myder; // geçersiz
}


- Private kalıtmı composition(containment, yani bir sınıf türünden elemana sahip olması)'a bir alternatif. İkisi arasındaki farklar:

a)Elemanımız olan sınıfın protected bölümüne erişemeyiz. Ancak private kalıtımda taban sınıfımızın protected bölümüne erişebilriz.
b)Elemenımızın sanal fonksiyonunu(doğrudan) override edemeyiz. Ancak private kalıtımda taban sınıfımızın sanal fonksiyonu override edebiliriz.
c)Elemanımızın türüne sınıf türünden dönüşüm yok. Ancak private kalıtımda sınırlı da olsa türemiş sınıftan taban sınıfa dönüşüm var(2. madde).

Private kalıtımda mümkün ama composition'da mümkün olmayan örnekler:

a) Bir sınıfın başka bir sınıf türünden iki tane elemanı olabilir.
b) Bir sınıfın başka bir sınıf türünden dizi elemanı olabilir.

Özet olarak private kalıtımında upcasting için:

a)Gloabal fonksiyonlarda geçerli değil.
b)Türemiş sınıfın üye fonksiyonları içinde geçerli.
c)Türemiş fonksiyonun friend'lik verdiği kodlar içinde geçerli.

EBO(Empty Base Optimization)
-------------------------------
Boş bir sınıfın bellekte kapladığı alan 1 byte'tır. Eğer böyle bir sınıf type member olarak başka bir sınıfın içinde yer alırsa, alignment nedeniyle
derleyici tarafından padding yapılabilir(ör:1 yerine 4 byte'lık yer kaplayabilir). Bu nedenden bu sınıftan kalıtım yapılması tercih edilir.

Neden Boş sınıf oluşturulur?
a)Sınıfın elemana sahip olmaması, bir interface'inin olmayacağı anlamına gelmiyor.
b)Böyle sınıflar bazı tekniklerle overload resolution oluşturmak için kullanılır.
c)Generic programlama paradigmasında empty class'lar yığun olarak kullanılır.

Private inhertance'ın Herb Sutter tarafından kullanılan ilginç bir kullanım senaryosu daha var. Bu senaryoya "restricted polymorphism" de deniyor.
Taban sınıftaki sanal fonksiyonun, virtual dispatch mekanizmasından sadece belirli fonksiyonların istifade etmesini sağlamak için kullanılır. 

class Base
{
public:
	virtual void vfunc();
};

class Der:private Base
{
public:
	void vfunc() override;
	friend void g1();
};

void foo(Base& r)
{
	r.vfunc();
}

void g1()
{
	Der1 myder;
	foo1(myder); // geçerli, friend func
}

void g2()
{
	Der1 myder;
	//foo1(myder); // geçersiz
}


PROTECTED INHERITANCE
------------------------

Private kalıtımı ile protected kalıtımı arasındaki en büyük fark:

	base public 		--> 	derived protected

Bu durumda multi-level inheritance ile türetilen sınıflar bu öğelere erişebilir.


Konuyla ilgili Diğer Kavramlar(Multiple Inheritance & Virtual Inheritance)



MULTIPLE INHERTIANCE
-----------------------

class BaseX { int x;}
class BaseY { int y;}

class Der : public BaseX, BaseY {}

Bunun anlamı class Der : public BaseX, private BaseY ile aynıdır. Der nesnesinin iki ayrı taban sınıfı var. Yani sizeof(Der) bu drummda 8 olacaktır.

Taban sınıflar kalıtım sentaksında bildirimdeki sıra ile hayata gelir(ctor init listteki sıra ile değil, member'larda olduğu gibi)

class Der : public BaseX, public BaseY // Bu sıra ile hayata gelir
{
	Der(): BaseY(), BaseX
}

İsim arama bütün sınıflarda(türemiş ve taban sınıflar) aynı anda yapılır, dolayısıyla function overloading olmaz(zaten scope'lar da farklı).
Burada ambiguity'i engellemenin yolu: static_cast operatörü ya da nitelenmiş isim kullanmaktır. Ör:

class BaseX
{
public:
	void foo()
	{
		std::cout << "BaseX foo()\n";
	}
};

class BaseY
{
public:
	int foo(int, int)
	{
		std::cout << "BaseY foo(int, int)\n";
		return {};
	}
};

class Der : public BaseX, public BaseY
{

};

int main()
{
	Der myder;

	myder.BaseX::foo();
	myder.BaseY::foo(1, 2);

	static_cast<BaseX&>(myder).foo();
	static_cast<BaseY&>(myder).foo(1, 2);
}

Output:
-------
BaseX foo()
BaseY foo(int, int)
BaseX foo()
BaseY foo(int, int)

Eğer function overloading mekanizmasının çalışması isteniyorsa türemiş sınıf içinde iki taban sınıf için de using bildirimi yapılabilir:

class BaseX
{
public:
	void foo()
	{
		std::cout << "BaseX foo()\n";
	}
};

class BaseY
{
public:
	int foo(int, int)
	{
		std::cout << "BaseY foo(int, int)\n";
		return {};
	}
};

class Der : public BaseX, public BaseY
{
public:
	using BaseX::foo;
	using BaseY::foo;
};

int main()
{
	Der myder;

	myder.foo();
	myder.foo(5, 6);
}

DIAMOND FORMATION PROBLEM (DREADFUL DIAMOND OF DERIVATION)
---------------------------

Diamond(karo) formdaki hiyerarşide çıkan, türemiş sınıf türünden bir nesne(MathTeacher) tanımlandığında taban sınıf 
nesnesinin(Person) iki kere hayata gelmesi problemini(ambiguity) çözmeye yönelik bir araçtır. Sentaksı:

class Person{};
class Employee:  virtual public Person{};
class Engineer:  virtual public Person{};
class Developer: public Employee, public Engineer{};


Eğer virtual inheritance kullanılarak türetilen sınıf(Employee ve Engineer), çoklu kalıtımda başka bir sınıfla birlikte taban sınıf olacaksa,
virtual inheritance sentaksi kendi taban  sınıfından bir tane koyulmasını sağlayacak. Bu sentaksta iki taban sınıfın da(Employee ve Engineer) 
virtual inheritance youlya elde edilmesi gerek, aksi takdirde virtual inheritance mekanizması devreye girmeyecektir. Burada ortak taban sınıfa(Person) 
virtual base class denir. nameVirtual base class, kendisinden türemiş sınıflarının hepsinin ctor'ları tarafından initialize edilmek zorundadır.

class Person // virtual base class
{
public:
	Person(const char* arg)
	{
		std::cout << arg << '\n';
	}
};

class Employee : virtual public Person
{
public:
	Employee() : Person("Employee") {}
};

class Engineer : virtual public Person
{
public:
	Engineer() : Person("Engineer") {}
};

class Developer : public Employee, public Engineer
{
public:
	Developer() : Person("Developer") {}
};

class Senior_Developer : public Developer
{
public:
	Senior_Developer() : Person("Senior_Developer") {}
};

int main()
{
	Person per{"Person"};
	Engineer eng;
	Employee emp;
	Developer dev;
	Senior_Developer Sdev;
}

Output:
-------
Person
Engineer
Employee
Developer
Senior_Developer