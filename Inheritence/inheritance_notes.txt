INHERITANCE - Main Features
--------------------------------------

Inside a derived class object, there is actually a base class object. This can be seen in the assembly code generated by the compiler and examined by using the sizeof operand.
sizeof(Base) <---> sizeof(Derived)

The base class to be inherited from, must be a complete type.

In a derived class, writing a "using declaration" for member functions or data members of the base class can have two purposes:

1) Adding the members(those not in private but possible protected) of the base class into the public interface of the derived class so that client codes
of derived class can use them.

2) Forming a function overloading mechanism between base class functions and derived class functions. If the derived class has a function with the same
name and parametres, then derived class functions will have the priority. Example:

class Base
{
protected:
	void foo(int x)
	{
		cout << "Base::foo(int x)\n";
	}

	void bar(int x)
	{
		cout << "Base::bar(int x)\n";
	}

	void baz(int x)
	{
		cout << "Base::baz(int x)\n";
	}
};

class Derived: public Base
{
public:
	void bar(double x)
	{
		cout << "Der::bar(double x)\n";
	}

	void baz(int x)
	{
		cout << "Derived::baz(int x)\n";
	}

	using Base::foo;
	using Base::bar;
};

// test code
int main()
{
	Derived dx;

	dx.foo(5);	// added base class function to derived class public interface
	dx.bar(5);	// function overloading, base class object bar function ced 
	dx.bar(5.);	// function overloading, derived class object bar function ced 
	dx.baz(5);	// both derived and base have the same function, it's not ambiguity. Derived class function has priority.
}

Output
------
Base::foo(int x)
Base::bar(int x)
Der::bar(double x)
Derived::baz(int x)

Special member functions work similarly to composition. For  implicitly declared - defaulted special functions written by the compiler in the derived
class functions, their base class counterparts are called (ex: Derived class default ctor --> Base class default ctor). However, in the derived class,
if a special member function is defined by the user, cing its base class counterparts(ctors, assignment operators or dtor) in the derived class member
function will be user's responsibility. Example:

class Base
{
public:
	Base() { cout << "Base()\n"; }

	Base(int, int) { cout << "Base(int, int)\n"; }

	Base(const Base& rhs)
	{
		cout << "Base(const Base& rhs)\n";
	}

	Base(Base&& rhs) noexcept
	{
		cout << "Base(Base&& rhs)\n";
	}

	Base& operator=(const Base& rhs)
	{
		cout << "Base& operator=(const Base& rhs)\n";
		return *this;
	}

	Base& operator=(Base&& rhs) noexcept
	{
		cout << "Base& operator=(Base&& rhs)\n";
		return *this;
	}

	void foo(int x)
	{
		cout << "Base::foo(int x)\n";
	}
};

class Der : public Base
{
public:
	Der() { cout << "Der()\n"; }

	Der(int x, int y) : Base(x, y)
	{
		cout << "Der(int, int)\n";
	}

	Der(const Der& rhs) : Base (rhs)
	{

		cout << "Der(const Der& rhs)\n";
	}

	Der(Der&& rhs) noexcept : Base (std::move(rhs))
	{
		cout << "Der(Der&& rhs)\n";
	}


	Der& operator=(const Der& rhs) 
	{
		Base::operator=(rhs);
		cout << "Der& operator=(const Der& rhs)\n";
		return *this;
	}

	Der& operator=(Der&& rhs) noexcept
	{
		Base::operator=(std::move(rhs));
		cout << "Der& operator=(Der&& rhs)\n";
		return *this;
	}
};

// test code
int main()
{
	Der da;			// default ctor
	cout << "\n";
	Der db(3, 5);		// (int, int) ctor
	cout << "\n";
	Der dc = db;		// copy ctor
	cout << "\n";
	Der dd = std::move(da);	// move ctor
	cout << "\n";
	da = dd;		// copy assignment operator
	cout << "\n";
	db = std::move(dc);	// move assignment operator
	cout << "\n";
	db.Base::foo(5);	// calling Base class function through a derived object
	db.foo(5);		// since it's a public inheritance, derived class object also has base class public functions
}

Output:
-------
Base()
Der()

Base(int, int)
Der(int, int)

Base(const Base& rhs)
Der(const Der& rhs)

Base(Base&& rhs)
Der(Der&& rhs)

Base& operator=(const Base& rhs)
Der& operator=(const Der& rhs)

Base& operator=(Base&& rhs)
Der& operator=(Der&& rhs)

Base::foo(int x)
Base::foo(int x)

Since modern C++, "inherited ctor" syntax added to language. This feature saves the the programmer from the hassle of defining derived class ctors for all
of its base class counterparts. However, this is not feasible if base class ctors are placed in protected access control section.

class Base
{
public:
	Base() { cout << "Base()\n"; }

	Base(int)
	{
		cout << "Base(int)\n";
	}

	Base(const char*)
	{ 
		cout << "Base(const char*)\n"; 
	}

	Base(int, char)
	{
		cout << "Base(int, char)\n";
	}
};

class Der : public Base
{
public:
	using Base::Base;
};

// test code
int main()
{
	Der da;
	Der db(5);
	Der dc("Hello");
	Der dd(2, 'c');
}

Output:
-------
Base()
Base(int)
Base(const char*)
Base(int, char)

INHERITANCE TTYPES(Public, Private, Protected Inheritance)
-------------------------------------------------------------------

Public Inheritance
------------------
- Public inheritance provides an "is-a" relationship, implicit conversion from derived class to base class happens using reference/pointer syntax.
- The public interface of the base class is added to the public interface of the derived class, and the protected interface of the base class is added to the protected interface of the derived class.
- The private part of the base class is closed to the derived class in all inheritance forms.

The situation is different for other types of inheritance that are specific to C++.
 
PRIVATE INHERITANCE
--------------------

- In public inheritance, the interfaces of the base class are added to the derived class in the same way:

	base public 		--> 	derived public
	base protected 		--> 	derived protected
	
- However in Private inhertiance:
	
	base public 		--> 	derived private
	base protected 		--> 	derived private
	
This means (private inheritance): Protected and public parts of the base class can still be accessed within the derived class. However, client codes can no longer use the codes of the base class through the derived class.

- There is no is-a relationship. There is no implicit conversion from the derived class to the base class. Upcasting is a syntax error with two exceptions:

a) Valid (implicitly) within the derived class's member function
b) Valid in functions to which the derived class gives friendship

class Base
{
public:
	void foo();
};

class Der : private Base
{
	void bar()
	{
		Der myder;

		Base* bptr = &myder; // geçerli
		Base& bref = myder; // geçerli
	}
	friend void func();
};

void func()
{
	Der myder;

	Base* bptr = &myder; // geçerli
	Base& bref = myder; // geçerli
}

int main()
{
	Der myder;

	Base* bptr = &myder; // geçersiz
	Base& bref = myder; // geçersiz
}

- Private inheritance is an alternative to composition (containment, i.e. having a data member of a class type). Differences between the two:

a) We cannot access the protected section of the class that is our member. However, in private inheritance, we can access the protected section of our base class.
b) We cannot override the virtual function of our member (directly). However, in private inheritance, we can override the virtual function of our base class.
c) There is no conversion from the class type to the type of our member. However, in private inheritance, there is a limited conversion from the derived class to the base class (item 2).

Examples that are possible in private inheritance but not in composition:

a) A class can have two members of another class type.
b) A class can have an array of memvers of another class type.

In summary, upcasting in private inheritance:

a) Not valid in global functions.
b) Valid in member functions of the derived class.
c) It is also valid for codes where the derived function is considered as friend.

EBO(Empty Base Optimization)
-------------------------------
The memoery occupied by an empty class in memory is 1 byte. If such a class is included in another class as a type member, padding may be done by the compiler due to alignment purposes (e.g. it may occupy 4 bytes instead of 1). For this reason, inheritance from this class is preferred.

Why is an empty class formed in the firs place?

a) Just because a class does not have members does not mean that it will not have an interface.
b) Such classes are used to create overload resolution with some techniques.
c) Empty classes are used as stacks in the generic programming paradigm.

There is another interesting scenario of private inheritance employed by Herb Sutter. This scenario is also called "restricted polymorphism".
It is used to ensure that only certain functions benefit from the virtual dispatch mechanism of the virtual function in the base class.

class Base
{
public:
	virtual void vfunc();
};

class Der: private Base
{
public:
	void vfunc() override;
	friend void g1();
};

void foo(Base& r)
{
	r.vfunc();
}

void g1()
{
	Der1 myder;
	foo1(myder); // geçerli, friend func
}

void g2()
{
	Der1 myder;
	//foo1(myder); // geçersiz
}

PROTECTED INHERITANCE
------------------------

The most significant difference between private inheritance and protected inheritance:

base public --> derived protected

In this case, classes derived with multi-level inheritance can access these elements.

Other concepts related to this topic: Multiple Inheritance & Virtual Inheritance

MULTIPLE INHERTIANCE
-----------------------

class BaseX { int x;}
class BaseY { int y;}

class Der : public BaseX, BaseY {}

This means class Der : public BaseX is the same as private BaseY. Der object has two separate base classes. So sizeof(Der) will be 8 in this case.

Base classes come to life in the order declared in the inheritance syntax (not in the order in the ctor init list, as in members)

class Der : public BaseX, public BaseY // It comes to life in this order
{
	Der(): BaseY(), BaseX
}

Name lookup is done simultaneously in all classes (derived and base classes), so there is no function overloading (scopes are different anyway).
In order to prevent ambiguity here static_cast operator or a qualified name can be used. For example:

class BaseX
{
public:
	void foo()
	{
		std::cout << "BaseX foo()\n";
	}
};

class BaseY
{
public:
	int foo(int, int)
	{
		std::cout << "BaseY foo(int, int)\n";
		return {};
	}
};

class Der : public BaseX, public BaseY
{

};

int main()
{
	Der myder;

	myder.BaseX::foo();
	myder.BaseY::foo(1, 2);

	static_cast<BaseX&>(myder).foo();
	static_cast<BaseY&>(myder).foo(1, 2);
}

Output:
-------
BaseX foo()
BaseY foo(int, int)
BaseX foo()
BaseY foo(int, int)

If the function overloading mechanism is desired to be on action, then "using declaration" can be added for both base classes in the derived class:

class BaseX
{
public:
	void foo()
	{
		std::cout << "BaseX foo()\n";
	}
};

class BaseY
{
public:
	int foo(int, int)
	{
		std::cout << "BaseY foo(int, int)\n";
		return {};
	}
};

class Der : public BaseX, public BaseY
{
public:
	using BaseX::foo;
	using BaseY::foo;
};

int main()
{
	Der myder;

	myder.foo();
	myder.foo(5, 6);
}

DIAMOND FORMATION PROBLEM (DREADFUL DIAMOND OF DERIVATION)
---------------------------

It is a tool to solve the problem of the base class object coming to life twice (ambiguity) when an object of the derived class type is defined in the hierarchy in the form of diamond. Syntax:

class Person{};
class Employee:  virtual public Person{};
class Engineer:  virtual public Person{};
class Developer: public Employee, public Engineer{};

If the class that is derived by virtual inheritance (Employee and Engineer) will be a base class together with another class in multiple inheritance, the virtual inheritance syntax will ensure that only one of thie common base classes object is included in the derived class. In this syntax, both base classes (Employee and Engineer) must be obtained from virtual inheritance, otherwise the virtual inheritance mechanism will not be activated. Here, the common base class (Person) is called as virtual base class. Virtual base class must be initialized by the ctors of all of its derived classes.

class Person // virtual base class
{
public:
	Person(const char* arg)
	{
		std::cout << arg << '\n';
	}
};

class Employee : virtual public Person
{
public:
	Employee() : Person("Employee") {}
};

class Engineer : virtual public Person
{
public:
	Engineer() : Person("Engineer") {}
};

class Developer : public Employee, public Engineer
{
public:
	Developer() : Person("Developer") {}
};

class Senior_Developer : public Developer
{
public:
	Senior_Developer() : Person("Senior_Developer") {}
};

int main()
{
	Person per{"Person"};
	Engineer eng;
	Employee emp;
	Developer dev;
	Senior_Developer Sdev;
}

Output:
-------
Person
Engineer
Employee
Developer
Senior_Developer
