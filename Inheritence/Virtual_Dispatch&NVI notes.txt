VIRTUAL FUNCTIONS & VIRTUAL DISPATCH MECHANISM
*-----------------------------------------------------*

Virtual dispatch is the process of selecting which implementation of a virtual function to call at run time. Its main features:

1) Virtual functions can be placed in public, protected and private sections of base class and can be orverriden also in each section of derived class.
As long as they are called via pointer/reference to base class type, virtual dispatch mechanism will be on action. Referring to code in cpp file:
void car_game(Car* p){ p->test_car();}

2) Name lookup, context control and access control are related to static checks. These are done in compile-time.
Default arguments of function parameters are also evaluated in compile-time, therefore the parameter will take base class virtual funciton's argument.

3) There are cases when virtual dispatch mechanism doesn't get activated:

    a) In object slicing(initializing a base class object with a derived class object)
	
    b) For virtual function calls that are made inside base class ctors, becuase if otherwise, base class would try to use the members/resources of an
object(of derived class) that has not yet been constructed. Note that construction starts from base class and continues to derived classes in order.

    c) For virtual function calls that are made inside base class dtor, becuase if otherwise, base class would try to use the members/resources of a destroyed
object. Note that destruction is done in the reverse order of construction, first members/resources of derived class and then base class are destroyed.

    d) When a member is used with scope resolution operator in base class. For example: Base::a

4) Virtual dispatch mechanism has costs:

    a) For each polymorphic class a virtual function table is formed by compiler. It's the same table for all objects of this class and created during
runtime and employs dynamic storage, therefore allocating and freeing this memory will come with a considerable cost.

    b) Each polymorphic class object has a virtual pointer that points to its own virtual function table. You can check the size 
difference between a polymorphic class and a class that has no virtual funciton. Adding more than one virtual function won't change the class size.
Consequently, when virtual dispatch mechanism is active, accessing to an overridden function shall require double dereferencing.
Example: virtPtr->table[idx]

5) Each time when a derived class object is used, the base class object should be replaceable with it in terms of functionality on compile-time.
Opposite of this implementation is called improper inheritance. In some parts of code, due to virtual dispatch, which object to be used(base or derived class object)
will be decided during run-time, therefore improper inheritence may cause a run-time error. This rule corresponds to the "L" part of SOLID principles which stands
for Liskov Substition Principle(LSP). Its reminding motto - "Require no more, promise no less".

6) There is no virtual ctor in C++, instead there is virtual clone idiom that constructs the exact same derived class object
However, dtors can be virtual and almost every time it should be virtual.

7) In virtual dispatch mechanism, mostly objects with dynamic storage are used. They are typically managed and deleted via base class pointers.
The dynamic type of an object is mostly unknown for the programmer, it will be clear at run-time. If, in a function, delete operator is called for
Base class dtor, only Base class dtor is called even if the argument is pointer to Derived class object, so the programmer can suppose virtual dispatch
mechanism handled the deletion properly. But actually derived class object dtor never gets called. In order for derived types to call their own dtors at
run-time, dtors should be virtual.

class Base
{
public:
	~Base(){cout << "~Base()\n";} // should be --> virtual ~Base(), now all the derived classes of this base class implicitly override this dtor
};

class Der : public Base
{
public:
	~Der(){cout << "Der dtor releasing some resources\n";}
};

void fdel(Base* bptr)
{
	delete bptr; // calls Base dtor, not Der dtor. delete operator takes its operand as static type. 
}				 // undefined behaviour if the argument comes as Der*

int main()
{
	Der* derptr = new Der;
	fdel(derptr); 
}

8) Herb Sutter's advice: Dtor of a polymorphic base class should be either;

    a) Public virtual, or
    b) Protected non-virtual.

First suggestion should be clear since it is obvious that for deletion of derived classes by base class pointers, base class dtor slould be accessible(public) at compile-time.

Second suggestion: If it is desired to guarantee to prevent deleting a derived class object by the destructor of a base class object, firstly there is
no need for dtor of the base to be virtualy. Next, if the dtor of the base class put in protected session, client codes cannot call delete operator for base
class pointers, but can call for derived class pointers.

class Base
{
public:
	void del()
	{
		Base::~Base();
	}
protected:
	~Base(){cout << "~Base()\n";}
};

class Der : public Base
{
public:
	~Der(){cout << "Der dtor releasing some resources\n";}
};

void fdel(Base* bptr)
{
	bptr->del();
}

int main()
{
	Base* baseptr = new Der;
	Der* derptr = new Der;

	fdel(baseptr);
	delete derptr;
}

9) In C++ there are RTTI(Run-time Type Information) tools to determine the dynamic type of an object in run-time:

	a) dynamic_cast operator
	b) typeid operator

10) "Final" contextual keyword can be used by compilers to do devirtualization(an optimization about inferring which function will be called during compile-time, 
when virtual functions/classes are involved)

11) C++ is a hybrid language, it's not specifically object-oriented. In fact, its strength lies in generic programming paradigm.
There will be alternatives of different methodologies based on trade-offs.